# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Tell mypy (a type checker) to ignore all errors from this file.
# See https://mypy.readthedocs.io/en/stable/config_file.html?highlight=ignore-errors#confval-ignore_errors
# mypy: ignore-errors

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime

# Used for default argument values
DEFAULT = object()


class RustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return rust_call(_UniFFILib.ffi_ldk_node_3490_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return rust_call(_UniFFILib.ffi_ldk_node_3490_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return rust_call(_UniFFILib.ffi_ldk_node_3490_rustbuffer_free, self)

    def __str__(self):
        return "RustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def allocWithBuilder():
        """Context-manger to allocate a buffer using a RustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = RustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consumeWithStream(self):
        """Context-manager to consume a buffer using a RustBufferStream.

        The RustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = RustBufferStream(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer after consuming")
        finally:
            self.free()


class ForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "ForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class RustBufferStream(object):
    """
    Helper for structured reading of bytes from a RustBuffer
    """

    def __init__(self, rbuf):
        self.rbuf = rbuf
        self.offset = 0

    def remaining(self):
        return self.rbuf.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.rbuf.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        data = self.rbuf.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def readI8(self):
        return self._unpack_from(1, ">b")

    def readU8(self):
        return self._unpack_from(1, ">B")

    def readI16(self):
        return self._unpack_from(2, ">h")

    def readU16(self):
        return self._unpack_from(2, ">H")

    def readI32(self):
        return self._unpack_from(4, ">i")

    def readU32(self):
        return self._unpack_from(4, ">I")

    def readI64(self):
        return self._unpack_from(8, ">q")

    def readU64(self):
        return self._unpack_from(8, ">Q")

    def readFloat(self):
        v = self._unpack_from(4, ">f")
        return v

    def readDouble(self):
        return self._unpack_from(8, ">d")


class RustBufferBuilder(object):
    """
    Helper for structured writing of bytes into a RustBuffer.
    """

    def __init__(self):
        self.rbuf = RustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, numBytes):
        if self.rbuf.len + numBytes > self.rbuf.capacity:
            self.rbuf = RustBuffer.reserve(self.rbuf, numBytes)
        yield None
        self.rbuf.len += numBytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def writeI8(self, v):
        self._pack_into(1, ">b", v)

    def writeU8(self, v):
        self._pack_into(1, ">B", v)

    def writeI16(self, v):
        self._pack_into(2, ">h", v)

    def writeU16(self, v):
        self._pack_into(2, ">H", v)

    def writeI32(self, v):
        self._pack_into(4, ">i", v)

    def writeU32(self, v):
        self._pack_into(4, ">I", v)

    def writeI64(self, v):
        self._pack_into(8, ">q", v)

    def writeU64(self, v):
        self._pack_into(8, ">Q", v)

    def writeFloat(self, v):
        self._pack_into(4, ">f", v)

    def writeDouble(self, v):
        self._pack_into(8, ">d", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class RustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", RustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == RustCallStatus.CALL_SUCCESS:
            return "RustCallStatus(CALL_SUCCESS)"
        elif self.code == RustCallStatus.CALL_ERROR:
            return "RustCallStatus(CALL_ERROR)"
        elif self.code == RustCallStatus.CALL_PANIC:
            return "RustCallStatus(CALL_PANIC)"
        else:
            return "RustCallStatus(<invalid code>)"

def rust_call(fn, *args):
    # Call a rust function
    return rust_call_with_error(None, fn, *args)

def rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the FfiConverter for the error class that corresponds to the result.
    call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    if call_status.code == RustCallStatus.CALL_SUCCESS:
        return result
    elif call_status.code == RustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == RustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a RustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = FfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid RustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: RustBuffer, buf_ptr: *mut RustBuffer) -> int`
FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, RustBuffer, ctypes.POINTER(RustBuffer))
# Types conforming to `FfiConverterPrimitive` pass themselves directly over the FFI.
class FfiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

# Helper class for wrapper types that will always go through a RustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class FfiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consumeWithStream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with RustBuffer.allocWithBuilder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code,
# and the FFI Function declarations in a com.sun.jna.Library.
# This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
#
# XXX TODO: This will probably grow some magic for resolving megazording in future.
# E.g. we might start by looking for the named component in `libuniffi.so` and if
# that fails, fall back to loading it separately from `lib${componentName}.so`.

from pathlib import Path

def loadIndirect():
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    lib = libname.format("ldk_node")
    path = str(Path(__file__).parent / lib)
    return ctypes.cdll.LoadLibrary(path)

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniFFILib = loadIndirect()
_UniFFILib.ffi_ldk_node_3490_Builder_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_ldk_node_3490_Builder_object_free.restype = None
_UniFFILib.ldk_node_3490_Builder_new.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_Builder_new.restype = ctypes.c_void_p
_UniFFILib.ldk_node_3490_Builder_from_config.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_Builder_from_config.restype = ctypes.c_void_p
_UniFFILib.ldk_node_3490_Builder_set_entropy_seed_path.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_Builder_set_entropy_seed_path.restype = None
_UniFFILib.ldk_node_3490_Builder_set_entropy_seed_bytes.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_Builder_set_entropy_seed_bytes.restype = None
_UniFFILib.ldk_node_3490_Builder_set_entropy_bip39_mnemonic.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_Builder_set_entropy_bip39_mnemonic.restype = None
_UniFFILib.ldk_node_3490_Builder_set_esplora_server.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_Builder_set_esplora_server.restype = None
_UniFFILib.ldk_node_3490_Builder_set_gossip_source_p2p.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_Builder_set_gossip_source_p2p.restype = None
_UniFFILib.ldk_node_3490_Builder_set_gossip_source_rgs.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_Builder_set_gossip_source_rgs.restype = None
_UniFFILib.ldk_node_3490_Builder_set_storage_dir_path.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_Builder_set_storage_dir_path.restype = None
_UniFFILib.ldk_node_3490_Builder_set_network.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_Builder_set_network.restype = None
_UniFFILib.ldk_node_3490_Builder_set_listening_address.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_Builder_set_listening_address.restype = None
_UniFFILib.ldk_node_3490_Builder_build.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_Builder_build.restype = ctypes.c_void_p
_UniFFILib.ffi_ldk_node_3490_LDKNode_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_ldk_node_3490_LDKNode_object_free.restype = None
_UniFFILib.ldk_node_3490_LDKNode_start.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_start.restype = None
_UniFFILib.ldk_node_3490_LDKNode_stop.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_stop.restype = None
_UniFFILib.ldk_node_3490_LDKNode_next_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_next_event.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_wait_next_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_wait_next_event.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_event_handled.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_event_handled.restype = None
_UniFFILib.ldk_node_3490_LDKNode_node_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_node_id.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_listening_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_listening_address.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_new_onchain_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_new_onchain_address.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_send_to_onchain_address.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_send_to_onchain_address.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_send_all_to_onchain_address.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_send_all_to_onchain_address.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_spendable_onchain_balance_sats.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_spendable_onchain_balance_sats.restype = ctypes.c_uint64
_UniFFILib.ldk_node_3490_LDKNode_total_onchain_balance_sats.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_total_onchain_balance_sats.restype = ctypes.c_uint64
_UniFFILib.ldk_node_3490_LDKNode_connect.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_connect.restype = None
_UniFFILib.ldk_node_3490_LDKNode_disconnect.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_disconnect.restype = None
_UniFFILib.ldk_node_3490_LDKNode_connect_open_channel.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.c_uint64,
    RustBuffer,
    RustBuffer,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_connect_open_channel.restype = None
_UniFFILib.ldk_node_3490_LDKNode_close_channel.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_close_channel.restype = None
_UniFFILib.ldk_node_3490_LDKNode_update_channel_config.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_update_channel_config.restype = None
_UniFFILib.ldk_node_3490_LDKNode_sync_wallets.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_sync_wallets.restype = None
_UniFFILib.ldk_node_3490_LDKNode_send_payment.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_send_payment.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_send_payment_using_amount.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_send_payment_using_amount.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_send_spontaneous_payment.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_send_spontaneous_payment.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_receive_payment.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    RustBuffer,
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_receive_payment.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_receive_variable_amount_payment.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_receive_variable_amount_payment.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_payment.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_payment.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_remove_payment.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_remove_payment.restype = ctypes.c_int8
_UniFFILib.ldk_node_3490_LDKNode_list_payments.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_list_payments.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_list_peers.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_list_peers.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_list_channels.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_list_channels.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_sign_message.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_sign_message.restype = RustBuffer
_UniFFILib.ldk_node_3490_LDKNode_verify_signature.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_LDKNode_verify_signature.restype = ctypes.c_int8
_UniFFILib.ldk_node_3490_generate_entropy_mnemonic.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ldk_node_3490_generate_entropy_mnemonic.restype = RustBuffer
_UniFFILib.ffi_ldk_node_3490_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_ldk_node_3490_rustbuffer_alloc.restype = RustBuffer
_UniFFILib.ffi_ldk_node_3490_rustbuffer_from_bytes.argtypes = (
    ForeignBytes,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_ldk_node_3490_rustbuffer_from_bytes.restype = RustBuffer
_UniFFILib.ffi_ldk_node_3490_rustbuffer_free.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_ldk_node_3490_rustbuffer_free.restype = None
_UniFFILib.ffi_ldk_node_3490_rustbuffer_reserve.argtypes = (
    RustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_ldk_node_3490_rustbuffer_reserve.restype = RustBuffer

# Public interface members begin here.


class FfiConverterUInt8(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU8()

    @staticmethod
    def write(value, buf):
        buf.writeU8(value)

class FfiConverterUInt16(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU16()

    @staticmethod
    def write(value, buf):
        buf.writeU16(value)

class FfiConverterUInt32(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU32()

    @staticmethod
    def write(value, buf):
        buf.writeU32(value)

class FfiConverterUInt64(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU64()

    @staticmethod
    def write(value, buf):
        buf.writeU64(value)

class FfiConverterBool:
    @classmethod
    def read(cls, buf):
        return cls.lift(buf.readU8())

    @classmethod
    def write(cls, value, buf):
        buf.writeU8(cls.lower(value))

    @staticmethod
    def lift(value):
        return int(value) != 0

    @staticmethod
    def lower(value):
        return 1 if value else 0

class FfiConverterString:
    @staticmethod
    def read(buf):
        size = buf.readI32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8Bytes = buf.read(size)
        return utf8Bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8Bytes = value.encode("utf-8")
        buf.writeI32(len(utf8Bytes))
        buf.write(utf8Bytes)

    @staticmethod
    def lift(buf):
        with buf.consumeWithStream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with RustBuffer.allocWithBuilder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class Builder(object):
    def __init__(self, ):
        self._pointer = rust_call(_UniFFILib.ldk_node_3490_Builder_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_ldk_node_3490_Builder_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_config(cls, config):
        config = config
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.ldk_node_3490_Builder_from_config,
        FfiConverterTypeConfig.lower(config))
        return cls._make_instance_(pointer)
    

    def set_entropy_seed_path(self, seed_path):
        seed_path = seed_path
        
        rust_call(_UniFFILib.ldk_node_3490_Builder_set_entropy_seed_path,self._pointer,
        FfiConverterString.lower(seed_path))
    
    def set_entropy_seed_bytes(self, seed_bytes):
        seed_bytes = list(int(x) for x in seed_bytes)
        
        rust_call_with_error(
    FfiConverterTypeBuildError,_UniFFILib.ldk_node_3490_Builder_set_entropy_seed_bytes,self._pointer,
        FfiConverterSequenceUInt8.lower(seed_bytes))
    
    def set_entropy_bip39_mnemonic(self, mnemonic,passphrase):
        mnemonic = mnemonic
        
        passphrase = (None if passphrase is None else passphrase)
        
        rust_call(_UniFFILib.ldk_node_3490_Builder_set_entropy_bip39_mnemonic,self._pointer,
        FfiConverterTypeMnemonic.lower(mnemonic),
        FfiConverterOptionalString.lower(passphrase))
    
    def set_esplora_server(self, esplora_server_url):
        esplora_server_url = esplora_server_url
        
        rust_call(_UniFFILib.ldk_node_3490_Builder_set_esplora_server,self._pointer,
        FfiConverterString.lower(esplora_server_url))
    
    def set_gossip_source_p2p(self, ):
        rust_call(_UniFFILib.ldk_node_3490_Builder_set_gossip_source_p2p,self._pointer,)
    
    def set_gossip_source_rgs(self, rgs_server_url):
        rgs_server_url = rgs_server_url
        
        rust_call(_UniFFILib.ldk_node_3490_Builder_set_gossip_source_rgs,self._pointer,
        FfiConverterString.lower(rgs_server_url))
    
    def set_storage_dir_path(self, storage_dir_path):
        storage_dir_path = storage_dir_path
        
        rust_call(_UniFFILib.ldk_node_3490_Builder_set_storage_dir_path,self._pointer,
        FfiConverterString.lower(storage_dir_path))
    
    def set_network(self, network):
        network = network
        
        rust_call(_UniFFILib.ldk_node_3490_Builder_set_network,self._pointer,
        FfiConverterTypeNetwork.lower(network))
    
    def set_listening_address(self, listening_address):
        listening_address = listening_address
        
        rust_call(_UniFFILib.ldk_node_3490_Builder_set_listening_address,self._pointer,
        FfiConverterTypeNetAddress.lower(listening_address))
    
    def build(self, ):
        return FfiConverterTypeLdkNode.lift(
            rust_call_with_error(
    FfiConverterTypeBuildError,_UniFFILib.ldk_node_3490_Builder_build,self._pointer,)
        )
    


class FfiConverterTypeBuilder:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Builder):
            raise TypeError("Expected Builder instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Builder._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class LdkNode(object):

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_ldk_node_3490_LDKNode_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def start(self, ):
        rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_start,self._pointer,)
    
    def stop(self, ):
        rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_stop,self._pointer,)
    
    def next_event(self, ):
        return FfiConverterOptionalTypeEvent.lift(
            rust_call(_UniFFILib.ldk_node_3490_LDKNode_next_event,self._pointer,)
        )
    def wait_next_event(self, ):
        return FfiConverterTypeEvent.lift(
            rust_call(_UniFFILib.ldk_node_3490_LDKNode_wait_next_event,self._pointer,)
        )
    def event_handled(self, ):
        rust_call(_UniFFILib.ldk_node_3490_LDKNode_event_handled,self._pointer,)
    
    def node_id(self, ):
        return FfiConverterTypePublicKey.lift(
            rust_call(_UniFFILib.ldk_node_3490_LDKNode_node_id,self._pointer,)
        )
    def listening_address(self, ):
        return FfiConverterOptionalTypeNetAddress.lift(
            rust_call(_UniFFILib.ldk_node_3490_LDKNode_listening_address,self._pointer,)
        )
    def new_onchain_address(self, ):
        return FfiConverterTypeAddress.lift(
            rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_new_onchain_address,self._pointer,)
        )
    def send_to_onchain_address(self, address,amount_msat):
        address = address
        
        amount_msat = int(amount_msat)
        
        return FfiConverterTypeTxid.lift(
            rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_send_to_onchain_address,self._pointer,
        FfiConverterTypeAddress.lower(address),
        FfiConverterUInt64.lower(amount_msat))
        )
    def send_all_to_onchain_address(self, address):
        address = address
        
        return FfiConverterTypeTxid.lift(
            rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_send_all_to_onchain_address,self._pointer,
        FfiConverterTypeAddress.lower(address))
        )
    def spendable_onchain_balance_sats(self, ):
        return FfiConverterUInt64.lift(
            rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_spendable_onchain_balance_sats,self._pointer,)
        )
    def total_onchain_balance_sats(self, ):
        return FfiConverterUInt64.lift(
            rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_total_onchain_balance_sats,self._pointer,)
        )
    def connect(self, node_id,address,persist):
        node_id = node_id
        
        address = address
        
        persist = bool(persist)
        
        rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_connect,self._pointer,
        FfiConverterTypePublicKey.lower(node_id),
        FfiConverterTypeNetAddress.lower(address),
        FfiConverterBool.lower(persist))
    
    def disconnect(self, node_id):
        node_id = node_id
        
        rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_disconnect,self._pointer,
        FfiConverterTypePublicKey.lower(node_id))
    
    def connect_open_channel(self, node_id,address,channel_amount_sats,push_to_counterparty_msat,channel_config,announce_channel):
        node_id = node_id
        
        address = address
        
        channel_amount_sats = int(channel_amount_sats)
        
        push_to_counterparty_msat = (None if push_to_counterparty_msat is None else int(push_to_counterparty_msat))
        
        channel_config = (None if channel_config is None else channel_config)
        
        announce_channel = bool(announce_channel)
        
        rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_connect_open_channel,self._pointer,
        FfiConverterTypePublicKey.lower(node_id),
        FfiConverterTypeNetAddress.lower(address),
        FfiConverterUInt64.lower(channel_amount_sats),
        FfiConverterOptionalUInt64.lower(push_to_counterparty_msat),
        FfiConverterOptionalTypeChannelConfig.lower(channel_config),
        FfiConverterBool.lower(announce_channel))
    
    def close_channel(self, channel_id,counterparty_node_id):
        channel_id = channel_id
        
        counterparty_node_id = counterparty_node_id
        
        rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_close_channel,self._pointer,
        FfiConverterTypeChannelId.lower(channel_id),
        FfiConverterTypePublicKey.lower(counterparty_node_id))
    
    def update_channel_config(self, channel_id,counterparty_node_id,channel_config):
        channel_id = channel_id
        
        counterparty_node_id = counterparty_node_id
        
        channel_config = channel_config
        
        rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_update_channel_config,self._pointer,
        FfiConverterTypeChannelId.lower(channel_id),
        FfiConverterTypePublicKey.lower(counterparty_node_id),
        FfiConverterTypeChannelConfig.lower(channel_config))
    
    def sync_wallets(self, ):
        rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_sync_wallets,self._pointer,)
    
    def send_payment(self, invoice):
        invoice = invoice
        
        return FfiConverterTypePaymentHash.lift(
            rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_send_payment,self._pointer,
        FfiConverterTypeInvoice.lower(invoice))
        )
    def send_payment_using_amount(self, invoice,amount_msat):
        invoice = invoice
        
        amount_msat = int(amount_msat)
        
        return FfiConverterTypePaymentHash.lift(
            rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_send_payment_using_amount,self._pointer,
        FfiConverterTypeInvoice.lower(invoice),
        FfiConverterUInt64.lower(amount_msat))
        )
    def send_spontaneous_payment(self, amount_msat,node_id):
        amount_msat = int(amount_msat)
        
        node_id = node_id
        
        return FfiConverterTypePaymentHash.lift(
            rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_send_spontaneous_payment,self._pointer,
        FfiConverterUInt64.lower(amount_msat),
        FfiConverterTypePublicKey.lower(node_id))
        )
    def receive_payment(self, amount_msat,description,expiry_secs):
        amount_msat = int(amount_msat)
        
        description = description
        
        expiry_secs = int(expiry_secs)
        
        return FfiConverterTypeInvoice.lift(
            rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_receive_payment,self._pointer,
        FfiConverterUInt64.lower(amount_msat),
        FfiConverterString.lower(description),
        FfiConverterUInt32.lower(expiry_secs))
        )
    def receive_variable_amount_payment(self, description,expiry_secs):
        description = description
        
        expiry_secs = int(expiry_secs)
        
        return FfiConverterTypeInvoice.lift(
            rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_receive_variable_amount_payment,self._pointer,
        FfiConverterString.lower(description),
        FfiConverterUInt32.lower(expiry_secs))
        )
    def payment(self, payment_hash):
        payment_hash = payment_hash
        
        return FfiConverterOptionalTypePaymentDetails.lift(
            rust_call(_UniFFILib.ldk_node_3490_LDKNode_payment,self._pointer,
        FfiConverterTypePaymentHash.lower(payment_hash))
        )
    def remove_payment(self, payment_hash):
        payment_hash = payment_hash
        
        return FfiConverterBool.lift(
            rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_remove_payment,self._pointer,
        FfiConverterTypePaymentHash.lower(payment_hash))
        )
    def list_payments(self, ):
        return FfiConverterSequenceTypePaymentDetails.lift(
            rust_call(_UniFFILib.ldk_node_3490_LDKNode_list_payments,self._pointer,)
        )
    def list_peers(self, ):
        return FfiConverterSequenceTypePeerDetails.lift(
            rust_call(_UniFFILib.ldk_node_3490_LDKNode_list_peers,self._pointer,)
        )
    def list_channels(self, ):
        return FfiConverterSequenceTypeChannelDetails.lift(
            rust_call(_UniFFILib.ldk_node_3490_LDKNode_list_channels,self._pointer,)
        )
    def sign_message(self, msg):
        msg = list(int(x) for x in msg)
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeNodeError,_UniFFILib.ldk_node_3490_LDKNode_sign_message,self._pointer,
        FfiConverterSequenceUInt8.lower(msg))
        )
    def verify_signature(self, msg,sig,pkey):
        msg = list(int(x) for x in msg)
        
        sig = sig
        
        pkey = pkey
        
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.ldk_node_3490_LDKNode_verify_signature,self._pointer,
        FfiConverterSequenceUInt8.lower(msg),
        FfiConverterString.lower(sig),
        FfiConverterTypePublicKey.lower(pkey))
        )
    


class FfiConverterTypeLdkNode:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, LdkNode):
            raise TypeError("Expected LdkNode instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return LdkNode._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class ChannelConfig:

    def __init__(self, forwarding_fee_proportional_millionths, forwarding_fee_base_msat, cltv_expiry_delta, max_dust_htlc_exposure_msat, force_close_avoidance_max_fee_satoshis):
        self.forwarding_fee_proportional_millionths = forwarding_fee_proportional_millionths
        self.forwarding_fee_base_msat = forwarding_fee_base_msat
        self.cltv_expiry_delta = cltv_expiry_delta
        self.max_dust_htlc_exposure_msat = max_dust_htlc_exposure_msat
        self.force_close_avoidance_max_fee_satoshis = force_close_avoidance_max_fee_satoshis

    def __str__(self):
        return "ChannelConfig(forwarding_fee_proportional_millionths={}, forwarding_fee_base_msat={}, cltv_expiry_delta={}, max_dust_htlc_exposure_msat={}, force_close_avoidance_max_fee_satoshis={})".format(self.forwarding_fee_proportional_millionths, self.forwarding_fee_base_msat, self.cltv_expiry_delta, self.max_dust_htlc_exposure_msat, self.force_close_avoidance_max_fee_satoshis)

    def __eq__(self, other):
        if self.forwarding_fee_proportional_millionths != other.forwarding_fee_proportional_millionths:
            return False
        if self.forwarding_fee_base_msat != other.forwarding_fee_base_msat:
            return False
        if self.cltv_expiry_delta != other.cltv_expiry_delta:
            return False
        if self.max_dust_htlc_exposure_msat != other.max_dust_htlc_exposure_msat:
            return False
        if self.force_close_avoidance_max_fee_satoshis != other.force_close_avoidance_max_fee_satoshis:
            return False
        return True

class FfiConverterTypeChannelConfig(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ChannelConfig(
            forwarding_fee_proportional_millionths=FfiConverterUInt32.read(buf),
            forwarding_fee_base_msat=FfiConverterUInt32.read(buf),
            cltv_expiry_delta=FfiConverterUInt16.read(buf),
            max_dust_htlc_exposure_msat=FfiConverterUInt64.read(buf),
            force_close_avoidance_max_fee_satoshis=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt32.write(value.forwarding_fee_proportional_millionths, buf)
        FfiConverterUInt32.write(value.forwarding_fee_base_msat, buf)
        FfiConverterUInt16.write(value.cltv_expiry_delta, buf)
        FfiConverterUInt64.write(value.max_dust_htlc_exposure_msat, buf)
        FfiConverterUInt64.write(value.force_close_avoidance_max_fee_satoshis, buf)


class ChannelDetails:

    def __init__(self, channel_id, counterparty_node_id, funding_txo, channel_value_sats, unspendable_punishment_reserve, user_channel_id, feerate_sat_per_1000_weight, balance_msat, outbound_capacity_msat, inbound_capacity_msat, confirmations_required, confirmations, is_outbound, is_channel_ready, is_usable, is_public, cltv_expiry_delta):
        self.channel_id = channel_id
        self.counterparty_node_id = counterparty_node_id
        self.funding_txo = funding_txo
        self.channel_value_sats = channel_value_sats
        self.unspendable_punishment_reserve = unspendable_punishment_reserve
        self.user_channel_id = user_channel_id
        self.feerate_sat_per_1000_weight = feerate_sat_per_1000_weight
        self.balance_msat = balance_msat
        self.outbound_capacity_msat = outbound_capacity_msat
        self.inbound_capacity_msat = inbound_capacity_msat
        self.confirmations_required = confirmations_required
        self.confirmations = confirmations
        self.is_outbound = is_outbound
        self.is_channel_ready = is_channel_ready
        self.is_usable = is_usable
        self.is_public = is_public
        self.cltv_expiry_delta = cltv_expiry_delta

    def __str__(self):
        return "ChannelDetails(channel_id={}, counterparty_node_id={}, funding_txo={}, channel_value_sats={}, unspendable_punishment_reserve={}, user_channel_id={}, feerate_sat_per_1000_weight={}, balance_msat={}, outbound_capacity_msat={}, inbound_capacity_msat={}, confirmations_required={}, confirmations={}, is_outbound={}, is_channel_ready={}, is_usable={}, is_public={}, cltv_expiry_delta={})".format(self.channel_id, self.counterparty_node_id, self.funding_txo, self.channel_value_sats, self.unspendable_punishment_reserve, self.user_channel_id, self.feerate_sat_per_1000_weight, self.balance_msat, self.outbound_capacity_msat, self.inbound_capacity_msat, self.confirmations_required, self.confirmations, self.is_outbound, self.is_channel_ready, self.is_usable, self.is_public, self.cltv_expiry_delta)

    def __eq__(self, other):
        if self.channel_id != other.channel_id:
            return False
        if self.counterparty_node_id != other.counterparty_node_id:
            return False
        if self.funding_txo != other.funding_txo:
            return False
        if self.channel_value_sats != other.channel_value_sats:
            return False
        if self.unspendable_punishment_reserve != other.unspendable_punishment_reserve:
            return False
        if self.user_channel_id != other.user_channel_id:
            return False
        if self.feerate_sat_per_1000_weight != other.feerate_sat_per_1000_weight:
            return False
        if self.balance_msat != other.balance_msat:
            return False
        if self.outbound_capacity_msat != other.outbound_capacity_msat:
            return False
        if self.inbound_capacity_msat != other.inbound_capacity_msat:
            return False
        if self.confirmations_required != other.confirmations_required:
            return False
        if self.confirmations != other.confirmations:
            return False
        if self.is_outbound != other.is_outbound:
            return False
        if self.is_channel_ready != other.is_channel_ready:
            return False
        if self.is_usable != other.is_usable:
            return False
        if self.is_public != other.is_public:
            return False
        if self.cltv_expiry_delta != other.cltv_expiry_delta:
            return False
        return True

class FfiConverterTypeChannelDetails(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ChannelDetails(
            channel_id=FfiConverterTypeChannelId.read(buf),
            counterparty_node_id=FfiConverterTypePublicKey.read(buf),
            funding_txo=FfiConverterOptionalTypeOutPoint.read(buf),
            channel_value_sats=FfiConverterUInt64.read(buf),
            unspendable_punishment_reserve=FfiConverterOptionalUInt64.read(buf),
            user_channel_id=FfiConverterTypeUserChannelId.read(buf),
            feerate_sat_per_1000_weight=FfiConverterUInt32.read(buf),
            balance_msat=FfiConverterUInt64.read(buf),
            outbound_capacity_msat=FfiConverterUInt64.read(buf),
            inbound_capacity_msat=FfiConverterUInt64.read(buf),
            confirmations_required=FfiConverterOptionalUInt32.read(buf),
            confirmations=FfiConverterOptionalUInt32.read(buf),
            is_outbound=FfiConverterBool.read(buf),
            is_channel_ready=FfiConverterBool.read(buf),
            is_usable=FfiConverterBool.read(buf),
            is_public=FfiConverterBool.read(buf),
            cltv_expiry_delta=FfiConverterOptionalUInt16.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeChannelId.write(value.channel_id, buf)
        FfiConverterTypePublicKey.write(value.counterparty_node_id, buf)
        FfiConverterOptionalTypeOutPoint.write(value.funding_txo, buf)
        FfiConverterUInt64.write(value.channel_value_sats, buf)
        FfiConverterOptionalUInt64.write(value.unspendable_punishment_reserve, buf)
        FfiConverterTypeUserChannelId.write(value.user_channel_id, buf)
        FfiConverterUInt32.write(value.feerate_sat_per_1000_weight, buf)
        FfiConverterUInt64.write(value.balance_msat, buf)
        FfiConverterUInt64.write(value.outbound_capacity_msat, buf)
        FfiConverterUInt64.write(value.inbound_capacity_msat, buf)
        FfiConverterOptionalUInt32.write(value.confirmations_required, buf)
        FfiConverterOptionalUInt32.write(value.confirmations, buf)
        FfiConverterBool.write(value.is_outbound, buf)
        FfiConverterBool.write(value.is_channel_ready, buf)
        FfiConverterBool.write(value.is_usable, buf)
        FfiConverterBool.write(value.is_public, buf)
        FfiConverterOptionalUInt16.write(value.cltv_expiry_delta, buf)


class Config:

    def __init__(self, storage_dir_path = DEFAULT, network = DEFAULT, listening_address = DEFAULT, default_cltv_expiry_delta = DEFAULT, onchain_wallet_sync_interval_secs = DEFAULT, wallet_sync_interval_secs = DEFAULT, fee_rate_cache_update_interval_secs = DEFAULT, log_level = DEFAULT, trusted_peers_0conf = DEFAULT):
        if storage_dir_path is DEFAULT:
            self.storage_dir_path = "/tmp/ldk_node/"
        else:
            self.storage_dir_path = storage_dir_path
        if network is DEFAULT:
            self.network = Network.BITCOIN
        else:
            self.network = network
        if listening_address is DEFAULT:
            self.listening_address = None
        else:
            self.listening_address = listening_address
        if default_cltv_expiry_delta is DEFAULT:
            self.default_cltv_expiry_delta = 144
        else:
            self.default_cltv_expiry_delta = default_cltv_expiry_delta
        if onchain_wallet_sync_interval_secs is DEFAULT:
            self.onchain_wallet_sync_interval_secs = 80
        else:
            self.onchain_wallet_sync_interval_secs = onchain_wallet_sync_interval_secs
        if wallet_sync_interval_secs is DEFAULT:
            self.wallet_sync_interval_secs = 30
        else:
            self.wallet_sync_interval_secs = wallet_sync_interval_secs
        if fee_rate_cache_update_interval_secs is DEFAULT:
            self.fee_rate_cache_update_interval_secs = 600
        else:
            self.fee_rate_cache_update_interval_secs = fee_rate_cache_update_interval_secs
        if log_level is DEFAULT:
            self.log_level = LogLevel.DEBUG
        else:
            self.log_level = log_level
        if trusted_peers_0conf is DEFAULT:
            self.trusted_peers_0conf = []
        else:
            self.trusted_peers_0conf = trusted_peers_0conf

    def __str__(self):
        return "Config(storage_dir_path={}, network={}, listening_address={}, default_cltv_expiry_delta={}, onchain_wallet_sync_interval_secs={}, wallet_sync_interval_secs={}, fee_rate_cache_update_interval_secs={}, log_level={}, trusted_peers_0conf={})".format(self.storage_dir_path, self.network, self.listening_address, self.default_cltv_expiry_delta, self.onchain_wallet_sync_interval_secs, self.wallet_sync_interval_secs, self.fee_rate_cache_update_interval_secs, self.log_level, self.trusted_peers_0conf)

    def __eq__(self, other):
        if self.storage_dir_path != other.storage_dir_path:
            return False
        if self.network != other.network:
            return False
        if self.listening_address != other.listening_address:
            return False
        if self.default_cltv_expiry_delta != other.default_cltv_expiry_delta:
            return False
        if self.onchain_wallet_sync_interval_secs != other.onchain_wallet_sync_interval_secs:
            return False
        if self.wallet_sync_interval_secs != other.wallet_sync_interval_secs:
            return False
        if self.fee_rate_cache_update_interval_secs != other.fee_rate_cache_update_interval_secs:
            return False
        if self.log_level != other.log_level:
            return False
        if self.trusted_peers_0conf != other.trusted_peers_0conf:
            return False
        return True

class FfiConverterTypeConfig(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Config(
            storage_dir_path=FfiConverterString.read(buf),
            network=FfiConverterTypeNetwork.read(buf),
            listening_address=FfiConverterOptionalTypeNetAddress.read(buf),
            default_cltv_expiry_delta=FfiConverterUInt32.read(buf),
            onchain_wallet_sync_interval_secs=FfiConverterUInt64.read(buf),
            wallet_sync_interval_secs=FfiConverterUInt64.read(buf),
            fee_rate_cache_update_interval_secs=FfiConverterUInt64.read(buf),
            log_level=FfiConverterTypeLogLevel.read(buf),
            trusted_peers_0conf=FfiConverterSequenceTypePublicKey.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.storage_dir_path, buf)
        FfiConverterTypeNetwork.write(value.network, buf)
        FfiConverterOptionalTypeNetAddress.write(value.listening_address, buf)
        FfiConverterUInt32.write(value.default_cltv_expiry_delta, buf)
        FfiConverterUInt64.write(value.onchain_wallet_sync_interval_secs, buf)
        FfiConverterUInt64.write(value.wallet_sync_interval_secs, buf)
        FfiConverterUInt64.write(value.fee_rate_cache_update_interval_secs, buf)
        FfiConverterTypeLogLevel.write(value.log_level, buf)
        FfiConverterSequenceTypePublicKey.write(value.trusted_peers_0conf, buf)


class OutPoint:

    def __init__(self, txid, vout):
        self.txid = txid
        self.vout = vout

    def __str__(self):
        return "OutPoint(txid={}, vout={})".format(self.txid, self.vout)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        return True

class FfiConverterTypeOutPoint(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OutPoint(
            txid=FfiConverterTypeTxid.read(buf),
            vout=FfiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeTxid.write(value.txid, buf)
        FfiConverterUInt32.write(value.vout, buf)


class PaymentDetails:

    def __init__(self, hash, preimage, secret, amount_msat, direction, status):
        self.hash = hash
        self.preimage = preimage
        self.secret = secret
        self.amount_msat = amount_msat
        self.direction = direction
        self.status = status

    def __str__(self):
        return "PaymentDetails(hash={}, preimage={}, secret={}, amount_msat={}, direction={}, status={})".format(self.hash, self.preimage, self.secret, self.amount_msat, self.direction, self.status)

    def __eq__(self, other):
        if self.hash != other.hash:
            return False
        if self.preimage != other.preimage:
            return False
        if self.secret != other.secret:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.direction != other.direction:
            return False
        if self.status != other.status:
            return False
        return True

class FfiConverterTypePaymentDetails(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PaymentDetails(
            hash=FfiConverterTypePaymentHash.read(buf),
            preimage=FfiConverterOptionalTypePaymentPreimage.read(buf),
            secret=FfiConverterOptionalTypePaymentSecret.read(buf),
            amount_msat=FfiConverterOptionalUInt64.read(buf),
            direction=FfiConverterTypePaymentDirection.read(buf),
            status=FfiConverterTypePaymentStatus.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypePaymentHash.write(value.hash, buf)
        FfiConverterOptionalTypePaymentPreimage.write(value.preimage, buf)
        FfiConverterOptionalTypePaymentSecret.write(value.secret, buf)
        FfiConverterOptionalUInt64.write(value.amount_msat, buf)
        FfiConverterTypePaymentDirection.write(value.direction, buf)
        FfiConverterTypePaymentStatus.write(value.status, buf)


class PeerDetails:

    def __init__(self, node_id, address, is_persisted, is_connected):
        self.node_id = node_id
        self.address = address
        self.is_persisted = is_persisted
        self.is_connected = is_connected

    def __str__(self):
        return "PeerDetails(node_id={}, address={}, is_persisted={}, is_connected={})".format(self.node_id, self.address, self.is_persisted, self.is_connected)

    def __eq__(self, other):
        if self.node_id != other.node_id:
            return False
        if self.address != other.address:
            return False
        if self.is_persisted != other.is_persisted:
            return False
        if self.is_connected != other.is_connected:
            return False
        return True

class FfiConverterTypePeerDetails(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PeerDetails(
            node_id=FfiConverterTypePublicKey.read(buf),
            address=FfiConverterTypeNetAddress.read(buf),
            is_persisted=FfiConverterBool.read(buf),
            is_connected=FfiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypePublicKey.write(value.node_id, buf)
        FfiConverterTypeNetAddress.write(value.address, buf)
        FfiConverterBool.write(value.is_persisted, buf)
        FfiConverterBool.write(value.is_connected, buf)




class Event:
    def __init__(self):
        raise RuntimeError("Event cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PAYMENT_SUCCESSFUL(object):
        def __init__(self,payment_hash):
            
            self.payment_hash = payment_hash
            

        def __str__(self):
            return "Event.PAYMENT_SUCCESSFUL(payment_hash={})".format(self.payment_hash)

        def __eq__(self, other):
            if not other.is_payment_successful():
                return False
            if self.payment_hash != other.payment_hash:
                return False
            return True
    class PAYMENT_FAILED(object):
        def __init__(self,payment_hash):
            
            self.payment_hash = payment_hash
            

        def __str__(self):
            return "Event.PAYMENT_FAILED(payment_hash={})".format(self.payment_hash)

        def __eq__(self, other):
            if not other.is_payment_failed():
                return False
            if self.payment_hash != other.payment_hash:
                return False
            return True
    class PAYMENT_RECEIVED(object):
        def __init__(self,payment_hash, amount_msat):
            
            self.payment_hash = payment_hash
            self.amount_msat = amount_msat
            

        def __str__(self):
            return "Event.PAYMENT_RECEIVED(payment_hash={}, amount_msat={})".format(self.payment_hash, self.amount_msat)

        def __eq__(self, other):
            if not other.is_payment_received():
                return False
            if self.payment_hash != other.payment_hash:
                return False
            if self.amount_msat != other.amount_msat:
                return False
            return True
    class CHANNEL_PENDING(object):
        def __init__(self,channel_id, user_channel_id, former_temporary_channel_id, counterparty_node_id, funding_txo):
            
            self.channel_id = channel_id
            self.user_channel_id = user_channel_id
            self.former_temporary_channel_id = former_temporary_channel_id
            self.counterparty_node_id = counterparty_node_id
            self.funding_txo = funding_txo
            

        def __str__(self):
            return "Event.CHANNEL_PENDING(channel_id={}, user_channel_id={}, former_temporary_channel_id={}, counterparty_node_id={}, funding_txo={})".format(self.channel_id, self.user_channel_id, self.former_temporary_channel_id, self.counterparty_node_id, self.funding_txo)

        def __eq__(self, other):
            if not other.is_channel_pending():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.user_channel_id != other.user_channel_id:
                return False
            if self.former_temporary_channel_id != other.former_temporary_channel_id:
                return False
            if self.counterparty_node_id != other.counterparty_node_id:
                return False
            if self.funding_txo != other.funding_txo:
                return False
            return True
    class CHANNEL_READY(object):
        def __init__(self,channel_id, user_channel_id):
            
            self.channel_id = channel_id
            self.user_channel_id = user_channel_id
            

        def __str__(self):
            return "Event.CHANNEL_READY(channel_id={}, user_channel_id={})".format(self.channel_id, self.user_channel_id)

        def __eq__(self, other):
            if not other.is_channel_ready():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.user_channel_id != other.user_channel_id:
                return False
            return True
    class CHANNEL_CLOSED(object):
        def __init__(self,channel_id, user_channel_id):
            
            self.channel_id = channel_id
            self.user_channel_id = user_channel_id
            

        def __str__(self):
            return "Event.CHANNEL_CLOSED(channel_id={}, user_channel_id={})".format(self.channel_id, self.user_channel_id)

        def __eq__(self, other):
            if not other.is_channel_closed():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.user_channel_id != other.user_channel_id:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_payment_successful(self):
        return isinstance(self, Event.PAYMENT_SUCCESSFUL)
    def is_payment_failed(self):
        return isinstance(self, Event.PAYMENT_FAILED)
    def is_payment_received(self):
        return isinstance(self, Event.PAYMENT_RECEIVED)
    def is_channel_pending(self):
        return isinstance(self, Event.CHANNEL_PENDING)
    def is_channel_ready(self):
        return isinstance(self, Event.CHANNEL_READY)
    def is_channel_closed(self):
        return isinstance(self, Event.CHANNEL_CLOSED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Event.PAYMENT_SUCCESSFUL = type("Event.PAYMENT_SUCCESSFUL", (Event.PAYMENT_SUCCESSFUL, Event,), {})
Event.PAYMENT_FAILED = type("Event.PAYMENT_FAILED", (Event.PAYMENT_FAILED, Event,), {})
Event.PAYMENT_RECEIVED = type("Event.PAYMENT_RECEIVED", (Event.PAYMENT_RECEIVED, Event,), {})
Event.CHANNEL_PENDING = type("Event.CHANNEL_PENDING", (Event.CHANNEL_PENDING, Event,), {})
Event.CHANNEL_READY = type("Event.CHANNEL_READY", (Event.CHANNEL_READY, Event,), {})
Event.CHANNEL_CLOSED = type("Event.CHANNEL_CLOSED", (Event.CHANNEL_CLOSED, Event,), {})




class FfiConverterTypeEvent(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return Event.PAYMENT_SUCCESSFUL(
                FfiConverterTypePaymentHash.read(buf),
            )
        if variant == 2:
            return Event.PAYMENT_FAILED(
                FfiConverterTypePaymentHash.read(buf),
            )
        if variant == 3:
            return Event.PAYMENT_RECEIVED(
                FfiConverterTypePaymentHash.read(buf),
                FfiConverterUInt64.read(buf),
            )
        if variant == 4:
            return Event.CHANNEL_PENDING(
                FfiConverterTypeChannelId.read(buf),
                FfiConverterTypeUserChannelId.read(buf),
                FfiConverterTypeChannelId.read(buf),
                FfiConverterTypePublicKey.read(buf),
                FfiConverterTypeOutPoint.read(buf),
            )
        if variant == 5:
            return Event.CHANNEL_READY(
                FfiConverterTypeChannelId.read(buf),
                FfiConverterTypeUserChannelId.read(buf),
            )
        if variant == 6:
            return Event.CHANNEL_CLOSED(
                FfiConverterTypeChannelId.read(buf),
                FfiConverterTypeUserChannelId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_payment_successful():
            buf.writeI32(1)
            FfiConverterTypePaymentHash.write(value.payment_hash, buf)
        if value.is_payment_failed():
            buf.writeI32(2)
            FfiConverterTypePaymentHash.write(value.payment_hash, buf)
        if value.is_payment_received():
            buf.writeI32(3)
            FfiConverterTypePaymentHash.write(value.payment_hash, buf)
            FfiConverterUInt64.write(value.amount_msat, buf)
        if value.is_channel_pending():
            buf.writeI32(4)
            FfiConverterTypeChannelId.write(value.channel_id, buf)
            FfiConverterTypeUserChannelId.write(value.user_channel_id, buf)
            FfiConverterTypeChannelId.write(value.former_temporary_channel_id, buf)
            FfiConverterTypePublicKey.write(value.counterparty_node_id, buf)
            FfiConverterTypeOutPoint.write(value.funding_txo, buf)
        if value.is_channel_ready():
            buf.writeI32(5)
            FfiConverterTypeChannelId.write(value.channel_id, buf)
            FfiConverterTypeUserChannelId.write(value.user_channel_id, buf)
        if value.is_channel_closed():
            buf.writeI32(6)
            FfiConverterTypeChannelId.write(value.channel_id, buf)
            FfiConverterTypeUserChannelId.write(value.user_channel_id, buf)




class LogLevel(enum.Enum):
    GOSSIP = 1
    TRACE = 2
    DEBUG = 3
    INFO = 4
    WARN = 5
    ERROR = 6
    


class FfiConverterTypeLogLevel(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return LogLevel.GOSSIP
        if variant == 2:
            return LogLevel.TRACE
        if variant == 3:
            return LogLevel.DEBUG
        if variant == 4:
            return LogLevel.INFO
        if variant == 5:
            return LogLevel.WARN
        if variant == 6:
            return LogLevel.ERROR
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == LogLevel.GOSSIP:
            buf.writeI32(1)
        if value == LogLevel.TRACE:
            buf.writeI32(2)
        if value == LogLevel.DEBUG:
            buf.writeI32(3)
        if value == LogLevel.INFO:
            buf.writeI32(4)
        if value == LogLevel.WARN:
            buf.writeI32(5)
        if value == LogLevel.ERROR:
            buf.writeI32(6)




class Network(enum.Enum):
    BITCOIN = 1
    TESTNET = 2
    SIGNET = 3
    REGTEST = 4
    


class FfiConverterTypeNetwork(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return Network.BITCOIN
        if variant == 2:
            return Network.TESTNET
        if variant == 3:
            return Network.SIGNET
        if variant == 4:
            return Network.REGTEST
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Network.BITCOIN:
            buf.writeI32(1)
        if value == Network.TESTNET:
            buf.writeI32(2)
        if value == Network.SIGNET:
            buf.writeI32(3)
        if value == Network.REGTEST:
            buf.writeI32(4)




class PaymentDirection(enum.Enum):
    INBOUND = 1
    OUTBOUND = 2
    


class FfiConverterTypePaymentDirection(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return PaymentDirection.INBOUND
        if variant == 2:
            return PaymentDirection.OUTBOUND
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == PaymentDirection.INBOUND:
            buf.writeI32(1)
        if value == PaymentDirection.OUTBOUND:
            buf.writeI32(2)




class PaymentStatus(enum.Enum):
    PENDING = 1
    SUCCEEDED = 2
    FAILED = 3
    


class FfiConverterTypePaymentStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return PaymentStatus.PENDING
        if variant == 2:
            return PaymentStatus.SUCCEEDED
        if variant == 3:
            return PaymentStatus.FAILED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == PaymentStatus.PENDING:
            buf.writeI32(1)
        if value == PaymentStatus.SUCCEEDED:
            buf.writeI32(2)
        if value == PaymentStatus.FAILED:
            buf.writeI32(3)



# BuildError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class BuildError(Exception):
        pass
    
    class InvalidSeedBytes(BuildError):
        def __str__(self):
            return "BuildError.InvalidSeedBytes({})".format(repr(super().__str__()))

    BuildError.InvalidSeedBytes = InvalidSeedBytes
    class InvalidSeedFile(BuildError):
        def __str__(self):
            return "BuildError.InvalidSeedFile({})".format(repr(super().__str__()))

    BuildError.InvalidSeedFile = InvalidSeedFile
    class InvalidSystemTime(BuildError):
        def __str__(self):
            return "BuildError.InvalidSystemTime({})".format(repr(super().__str__()))

    BuildError.InvalidSystemTime = InvalidSystemTime
    class ReadFailed(BuildError):
        def __str__(self):
            return "BuildError.ReadFailed({})".format(repr(super().__str__()))

    BuildError.ReadFailed = ReadFailed
    class WriteFailed(BuildError):
        def __str__(self):
            return "BuildError.WriteFailed({})".format(repr(super().__str__()))

    BuildError.WriteFailed = WriteFailed
    class StoragePathAccessFailed(BuildError):
        def __str__(self):
            return "BuildError.StoragePathAccessFailed({})".format(repr(super().__str__()))

    BuildError.StoragePathAccessFailed = StoragePathAccessFailed
    class WalletSetupFailed(BuildError):
        def __str__(self):
            return "BuildError.WalletSetupFailed({})".format(repr(super().__str__()))

    BuildError.WalletSetupFailed = WalletSetupFailed
    class LoggerSetupFailed(BuildError):
        def __str__(self):
            return "BuildError.LoggerSetupFailed({})".format(repr(super().__str__()))

    BuildError.LoggerSetupFailed = LoggerSetupFailed
BuildError = UniFFIExceptionTmpNamespace.BuildError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeBuildError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return BuildError.InvalidSeedBytes(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return BuildError.InvalidSeedFile(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return BuildError.InvalidSystemTime(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return BuildError.ReadFailed(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return BuildError.WriteFailed(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return BuildError.StoragePathAccessFailed(
                FfiConverterString.read(buf),
            )
        if variant == 7:
            return BuildError.WalletSetupFailed(
                FfiConverterString.read(buf),
            )
        if variant == 8:
            return BuildError.LoggerSetupFailed(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, BuildError.InvalidSeedBytes):
            buf.writeI32(1)
        if isinstance(value, BuildError.InvalidSeedFile):
            buf.writeI32(2)
        if isinstance(value, BuildError.InvalidSystemTime):
            buf.writeI32(3)
        if isinstance(value, BuildError.ReadFailed):
            buf.writeI32(4)
        if isinstance(value, BuildError.WriteFailed):
            buf.writeI32(5)
        if isinstance(value, BuildError.StoragePathAccessFailed):
            buf.writeI32(6)
        if isinstance(value, BuildError.WalletSetupFailed):
            buf.writeI32(7)
        if isinstance(value, BuildError.LoggerSetupFailed):
            buf.writeI32(8)



# NodeError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class NodeError(Exception):
        pass
    
    class AlreadyRunning(NodeError):
        def __str__(self):
            return "NodeError.AlreadyRunning({})".format(repr(super().__str__()))

    NodeError.AlreadyRunning = AlreadyRunning
    class NotRunning(NodeError):
        def __str__(self):
            return "NodeError.NotRunning({})".format(repr(super().__str__()))

    NodeError.NotRunning = NotRunning
    class OnchainTxCreationFailed(NodeError):
        def __str__(self):
            return "NodeError.OnchainTxCreationFailed({})".format(repr(super().__str__()))

    NodeError.OnchainTxCreationFailed = OnchainTxCreationFailed
    class ConnectionFailed(NodeError):
        def __str__(self):
            return "NodeError.ConnectionFailed({})".format(repr(super().__str__()))

    NodeError.ConnectionFailed = ConnectionFailed
    class InvoiceCreationFailed(NodeError):
        def __str__(self):
            return "NodeError.InvoiceCreationFailed({})".format(repr(super().__str__()))

    NodeError.InvoiceCreationFailed = InvoiceCreationFailed
    class PaymentSendingFailed(NodeError):
        def __str__(self):
            return "NodeError.PaymentSendingFailed({})".format(repr(super().__str__()))

    NodeError.PaymentSendingFailed = PaymentSendingFailed
    class ChannelCreationFailed(NodeError):
        def __str__(self):
            return "NodeError.ChannelCreationFailed({})".format(repr(super().__str__()))

    NodeError.ChannelCreationFailed = ChannelCreationFailed
    class ChannelClosingFailed(NodeError):
        def __str__(self):
            return "NodeError.ChannelClosingFailed({})".format(repr(super().__str__()))

    NodeError.ChannelClosingFailed = ChannelClosingFailed
    class ChannelConfigUpdateFailed(NodeError):
        def __str__(self):
            return "NodeError.ChannelConfigUpdateFailed({})".format(repr(super().__str__()))

    NodeError.ChannelConfigUpdateFailed = ChannelConfigUpdateFailed
    class PersistenceFailed(NodeError):
        def __str__(self):
            return "NodeError.PersistenceFailed({})".format(repr(super().__str__()))

    NodeError.PersistenceFailed = PersistenceFailed
    class WalletOperationFailed(NodeError):
        def __str__(self):
            return "NodeError.WalletOperationFailed({})".format(repr(super().__str__()))

    NodeError.WalletOperationFailed = WalletOperationFailed
    class OnchainTxSigningFailed(NodeError):
        def __str__(self):
            return "NodeError.OnchainTxSigningFailed({})".format(repr(super().__str__()))

    NodeError.OnchainTxSigningFailed = OnchainTxSigningFailed
    class MessageSigningFailed(NodeError):
        def __str__(self):
            return "NodeError.MessageSigningFailed({})".format(repr(super().__str__()))

    NodeError.MessageSigningFailed = MessageSigningFailed
    class TxSyncFailed(NodeError):
        def __str__(self):
            return "NodeError.TxSyncFailed({})".format(repr(super().__str__()))

    NodeError.TxSyncFailed = TxSyncFailed
    class GossipUpdateFailed(NodeError):
        def __str__(self):
            return "NodeError.GossipUpdateFailed({})".format(repr(super().__str__()))

    NodeError.GossipUpdateFailed = GossipUpdateFailed
    class InvalidAddress(NodeError):
        def __str__(self):
            return "NodeError.InvalidAddress({})".format(repr(super().__str__()))

    NodeError.InvalidAddress = InvalidAddress
    class InvalidNetAddress(NodeError):
        def __str__(self):
            return "NodeError.InvalidNetAddress({})".format(repr(super().__str__()))

    NodeError.InvalidNetAddress = InvalidNetAddress
    class InvalidPublicKey(NodeError):
        def __str__(self):
            return "NodeError.InvalidPublicKey({})".format(repr(super().__str__()))

    NodeError.InvalidPublicKey = InvalidPublicKey
    class InvalidSecretKey(NodeError):
        def __str__(self):
            return "NodeError.InvalidSecretKey({})".format(repr(super().__str__()))

    NodeError.InvalidSecretKey = InvalidSecretKey
    class InvalidPaymentHash(NodeError):
        def __str__(self):
            return "NodeError.InvalidPaymentHash({})".format(repr(super().__str__()))

    NodeError.InvalidPaymentHash = InvalidPaymentHash
    class InvalidPaymentPreimage(NodeError):
        def __str__(self):
            return "NodeError.InvalidPaymentPreimage({})".format(repr(super().__str__()))

    NodeError.InvalidPaymentPreimage = InvalidPaymentPreimage
    class InvalidPaymentSecret(NodeError):
        def __str__(self):
            return "NodeError.InvalidPaymentSecret({})".format(repr(super().__str__()))

    NodeError.InvalidPaymentSecret = InvalidPaymentSecret
    class InvalidAmount(NodeError):
        def __str__(self):
            return "NodeError.InvalidAmount({})".format(repr(super().__str__()))

    NodeError.InvalidAmount = InvalidAmount
    class InvalidInvoice(NodeError):
        def __str__(self):
            return "NodeError.InvalidInvoice({})".format(repr(super().__str__()))

    NodeError.InvalidInvoice = InvalidInvoice
    class InvalidChannelId(NodeError):
        def __str__(self):
            return "NodeError.InvalidChannelId({})".format(repr(super().__str__()))

    NodeError.InvalidChannelId = InvalidChannelId
    class InvalidNetwork(NodeError):
        def __str__(self):
            return "NodeError.InvalidNetwork({})".format(repr(super().__str__()))

    NodeError.InvalidNetwork = InvalidNetwork
    class DuplicatePayment(NodeError):
        def __str__(self):
            return "NodeError.DuplicatePayment({})".format(repr(super().__str__()))

    NodeError.DuplicatePayment = DuplicatePayment
    class InsufficientFunds(NodeError):
        def __str__(self):
            return "NodeError.InsufficientFunds({})".format(repr(super().__str__()))

    NodeError.InsufficientFunds = InsufficientFunds
NodeError = UniFFIExceptionTmpNamespace.NodeError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeNodeError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return NodeError.AlreadyRunning(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return NodeError.NotRunning(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return NodeError.OnchainTxCreationFailed(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return NodeError.ConnectionFailed(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return NodeError.InvoiceCreationFailed(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return NodeError.PaymentSendingFailed(
                FfiConverterString.read(buf),
            )
        if variant == 7:
            return NodeError.ChannelCreationFailed(
                FfiConverterString.read(buf),
            )
        if variant == 8:
            return NodeError.ChannelClosingFailed(
                FfiConverterString.read(buf),
            )
        if variant == 9:
            return NodeError.ChannelConfigUpdateFailed(
                FfiConverterString.read(buf),
            )
        if variant == 10:
            return NodeError.PersistenceFailed(
                FfiConverterString.read(buf),
            )
        if variant == 11:
            return NodeError.WalletOperationFailed(
                FfiConverterString.read(buf),
            )
        if variant == 12:
            return NodeError.OnchainTxSigningFailed(
                FfiConverterString.read(buf),
            )
        if variant == 13:
            return NodeError.MessageSigningFailed(
                FfiConverterString.read(buf),
            )
        if variant == 14:
            return NodeError.TxSyncFailed(
                FfiConverterString.read(buf),
            )
        if variant == 15:
            return NodeError.GossipUpdateFailed(
                FfiConverterString.read(buf),
            )
        if variant == 16:
            return NodeError.InvalidAddress(
                FfiConverterString.read(buf),
            )
        if variant == 17:
            return NodeError.InvalidNetAddress(
                FfiConverterString.read(buf),
            )
        if variant == 18:
            return NodeError.InvalidPublicKey(
                FfiConverterString.read(buf),
            )
        if variant == 19:
            return NodeError.InvalidSecretKey(
                FfiConverterString.read(buf),
            )
        if variant == 20:
            return NodeError.InvalidPaymentHash(
                FfiConverterString.read(buf),
            )
        if variant == 21:
            return NodeError.InvalidPaymentPreimage(
                FfiConverterString.read(buf),
            )
        if variant == 22:
            return NodeError.InvalidPaymentSecret(
                FfiConverterString.read(buf),
            )
        if variant == 23:
            return NodeError.InvalidAmount(
                FfiConverterString.read(buf),
            )
        if variant == 24:
            return NodeError.InvalidInvoice(
                FfiConverterString.read(buf),
            )
        if variant == 25:
            return NodeError.InvalidChannelId(
                FfiConverterString.read(buf),
            )
        if variant == 26:
            return NodeError.InvalidNetwork(
                FfiConverterString.read(buf),
            )
        if variant == 27:
            return NodeError.DuplicatePayment(
                FfiConverterString.read(buf),
            )
        if variant == 28:
            return NodeError.InsufficientFunds(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, NodeError.AlreadyRunning):
            buf.writeI32(1)
        if isinstance(value, NodeError.NotRunning):
            buf.writeI32(2)
        if isinstance(value, NodeError.OnchainTxCreationFailed):
            buf.writeI32(3)
        if isinstance(value, NodeError.ConnectionFailed):
            buf.writeI32(4)
        if isinstance(value, NodeError.InvoiceCreationFailed):
            buf.writeI32(5)
        if isinstance(value, NodeError.PaymentSendingFailed):
            buf.writeI32(6)
        if isinstance(value, NodeError.ChannelCreationFailed):
            buf.writeI32(7)
        if isinstance(value, NodeError.ChannelClosingFailed):
            buf.writeI32(8)
        if isinstance(value, NodeError.ChannelConfigUpdateFailed):
            buf.writeI32(9)
        if isinstance(value, NodeError.PersistenceFailed):
            buf.writeI32(10)
        if isinstance(value, NodeError.WalletOperationFailed):
            buf.writeI32(11)
        if isinstance(value, NodeError.OnchainTxSigningFailed):
            buf.writeI32(12)
        if isinstance(value, NodeError.MessageSigningFailed):
            buf.writeI32(13)
        if isinstance(value, NodeError.TxSyncFailed):
            buf.writeI32(14)
        if isinstance(value, NodeError.GossipUpdateFailed):
            buf.writeI32(15)
        if isinstance(value, NodeError.InvalidAddress):
            buf.writeI32(16)
        if isinstance(value, NodeError.InvalidNetAddress):
            buf.writeI32(17)
        if isinstance(value, NodeError.InvalidPublicKey):
            buf.writeI32(18)
        if isinstance(value, NodeError.InvalidSecretKey):
            buf.writeI32(19)
        if isinstance(value, NodeError.InvalidPaymentHash):
            buf.writeI32(20)
        if isinstance(value, NodeError.InvalidPaymentPreimage):
            buf.writeI32(21)
        if isinstance(value, NodeError.InvalidPaymentSecret):
            buf.writeI32(22)
        if isinstance(value, NodeError.InvalidAmount):
            buf.writeI32(23)
        if isinstance(value, NodeError.InvalidInvoice):
            buf.writeI32(24)
        if isinstance(value, NodeError.InvalidChannelId):
            buf.writeI32(25)
        if isinstance(value, NodeError.InvalidNetwork):
            buf.writeI32(26)
        if isinstance(value, NodeError.DuplicatePayment):
            buf.writeI32(27)
        if isinstance(value, NodeError.InsufficientFunds):
            buf.writeI32(28)



class FfiConverterOptionalUInt16(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt16.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt16.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalUInt32(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalUInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeChannelConfig(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeChannelConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeChannelConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeOutPoint(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeOutPoint.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeOutPoint.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypePaymentDetails(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypePaymentDetails.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypePaymentDetails.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeEvent(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeEvent.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeEvent.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeNetAddress(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeNetAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeNetAddress.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypePaymentPreimage(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypePaymentPreimage.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypePaymentPreimage.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypePaymentSecret(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypePaymentSecret.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypePaymentSecret.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt8.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeChannelDetails(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeChannelDetails.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeChannelDetails.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypePaymentDetails(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypePaymentDetails.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypePaymentDetails.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypePeerDetails(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypePeerDetails.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypePeerDetails.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypePublicKey(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypePublicKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypePublicKey.read(buf) for i in range(count)
        ]


class FfiConverterTypeAddress:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeChannelId:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeInvoice:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeMnemonic:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeNetAddress:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypePaymentHash:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypePaymentPreimage:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypePaymentSecret:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypePublicKey:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeTxid:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeUserChannelId:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)

def generate_entropy_mnemonic():
    return FfiConverterTypeMnemonic.lift(rust_call(_UniFFILib.ldk_node_3490_generate_entropy_mnemonic,))



__all__ = [
    "InternalError",
    "Event",
    "LogLevel",
    "Network",
    "PaymentDirection",
    "PaymentStatus",
    "ChannelConfig",
    "ChannelDetails",
    "Config",
    "OutPoint",
    "PaymentDetails",
    "PeerDetails",
    "generate_entropy_mnemonic",
    "Builder",
    "LdkNode",
    "BuildError",
    "NodeError",
]

